<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climate Health Impact Dashboard</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.plot.ly/plotly-2.35.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
</head>
<body>

    <div class="header">
        <h1>Climate Health Impact Dashboard</h1>
    </div>

    <div class="filters-bar">
        <div class="filter-group">
            <label>Disaster Type</label>
            <select id="disaster-filter">
                <option value="heatwave">Heatwaves</option>
                <option value="flood">Floods</option>
                <option value="drought">Droughts</option>
            </select>
        </div>
        <div class="filter-group">
            <label>Region</label>
            <select id="region-filter">
                <option value="all">All Regions</option>
            </select>
        </div>
        <div class="filter-group">
            <label>Year Range</label>
            <div class="year-range">
                <select id="year-start">
                    <option>2015</option><option>2016</option><option>2017</option>
                    <option>2018</option><option>2019</option><option>2020</option>
                    <option>2021</option><option>2022</option><option>2023</option>
                    <option>2024</option><option>2025</option>
                </select>
                <span>to</span>
                <select id="year-end">
                    <option value="2025" selected>2025</option><option value="2024">2024</option>
                    <option value="2023">2023</option><option value="2022">2022</option>
                    <option value="2021">2021</option><option value="2020">2020</option>
                    <option value="2019">2019</option><option value="2018">2018</option>
                    <option value="2017">2017</option><option value="2016">2016</option>
                    <option value="2015">2015</option>
                </select>
            </div>
        </div>
    </div>

    <div class="main">

        <div class="stat-cards">
            <div class="stat-card">
                <div class="stat-label">Disaster Weeks</div>
                <div class="stat-value" id="stat-weeks">—</div>
                <div class="stat-detail" id="stat-weeks-detail"></div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Most Affected Region</div>
                <div class="stat-value" id="stat-region" style="font-size:1.15rem;">—</div>
                <div class="stat-detail" id="stat-region-detail"></div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Peak Risk Month</div>
                <div class="stat-value" id="stat-month">—</div>
                <div class="stat-detail">historically highest</div>
            </div>
        </div>

        <div class="chart-full">
            <h3>Health Impact Trend</h3>
            <div class="chart-subtitle">Yearly avg health impact during disaster vs normal weeks</div>
            <div id="trend-chart"></div>
        </div>

        <div class="chart-full">
            <h3>Global Health Impact Map</h3>
            <div class="chart-subtitle">Country-level avg health impact during disaster weeks</div>
            <div id="heatmap-chart"></div>
        </div>

        <div class="chart-full">
            <h3>Seasonal Pattern + Forecast</h3>
            <div class="chart-subtitle">Monthly avg across all data (solid) vs ML forecast (dashed, R² 0.87)</div>
            <div id="seasonal-chart"></div>
        </div>

        <div class="table-panel">
            <h3>Country Vulnerability Ranking</h3>
            <div class="chart-subtitle">Sorted by health impact — includes 2026 forecast</div>
            <table class="vuln-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Country</th>
                        <th>Region</th>
                        <th>Disaster Weeks</th>
                        <th>Avg Health Impact</th>
                        <th>2026 Forecast</th>
                        <th>Healthcare Access</th>
                    </tr>
                </thead>
                <tbody id="vuln-tbody"></tbody>
            </table>
        </div>

    </div>


<script>
const MONTH_NAMES = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

const DISASTER_CONFIG = {
    heatwave: {
        indicator: row => +row.heat_wave_days > 0,
        metric: row => +row.heat_related_admissions,
        metricLabel: 'Heat-Related Admissions',
        name: 'Heatwave',
        forecastKey: 'heat_related_admissions'
    },
    flood: {
        indicator: row => +row.flood_indicator === 1,
        metric: row => +row.waterborne_disease_incidents,
        metricLabel: 'Waterborne Disease Incidents',
        name: 'Flood',
        forecastKey: null
    },
    drought: {
        indicator: row => +row.drought_indicator === 1,
        metric: row => +row.respiratory_disease_rate,
        metricLabel: 'Respiratory Disease Rate',
        name: 'Drought',
        forecastKey: 'respiratory_disease_rate'
    }
};

const PLOTLY_LAYOUT = {
    paper_bgcolor: 'transparent',
    plot_bgcolor: 'transparent',
    font: { family: '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif', size: 11, color: '#888' },
    margin: { l: 48, r: 20, t: 10, b: 40 },
    xaxis: { gridcolor: '#f0f0f0', zerolinecolor: '#eee' },
    yaxis: { gridcolor: '#f0f0f0', zerolinecolor: '#eee' }
};

const PLOTLY_CONFIG = { displayModeBar: false, responsive: true };

let rawData = [];
let forecastData = {};
let countryMeta = {};

async function init() {
    const [csvText, fcResponse] = await Promise.all([
        fetch('cleaned_file.csv').then(r => r.text()),
        fetch('/api/forecast/all').then(r => r.json()).catch(() => ({}))
    ]);

    rawData = Papa.parse(csvText, { header: true, skipEmptyLines: true }).data;
    rawData.forEach(r => { if (+r.air_quality_index < 0) r.air_quality_index = '0'; });
    forecastData = fcResponse;

    const regions = [...new Set(rawData.map(r => r.region))].sort();
    const regionSelect = document.getElementById('region-filter');
    regions.forEach(r => {
        const opt = document.createElement('option');
        opt.value = r; opt.textContent = r;
        regionSelect.appendChild(opt);
    });

    rawData.forEach(r => {
        if (!countryMeta[r.country_name]) {
            countryMeta[r.country_name] = { code: r.country_code, region: r.region };
        }
    });

    updateDashboard();
}

init();

document.getElementById('disaster-filter').addEventListener('change', updateDashboard);
document.getElementById('region-filter').addEventListener('change', updateDashboard);
document.getElementById('year-start').addEventListener('change', updateDashboard);
document.getElementById('year-end').addEventListener('change', updateDashboard);

function updateDashboard() {
    const disasterType = document.getElementById('disaster-filter').value;
    const region = document.getElementById('region-filter').value;
    const yearStart = +document.getElementById('year-start').value;
    const yearEnd = +document.getElementById('year-end').value;
    const config = DISASTER_CONFIG[disasterType];

    let data = rawData.filter(r => {
        const y = +r.year;
        return y >= yearStart && y <= yearEnd && (region === 'all' || r.region === region);
    });

    const disasterRows = data.filter(config.indicator);
    const nonDisasterRows = data.filter(r => !config.indicator(r));
    const countries = [...new Set(data.map(r => r.country_name))].sort();

    // stat cards
    document.getElementById('stat-weeks').textContent = disasterRows.length.toLocaleString();
    document.getElementById('stat-weeks-detail').textContent = `across ${countries.length} countries`;


    const regionImpact = groupBy(disasterRows, 'region');
    let maxRegion = '—', maxVal = 0;
    for (const [reg, rows] of Object.entries(regionImpact)) {
        const avg = mean(rows.map(config.metric));
        if (avg > maxVal) { maxVal = avg; maxRegion = reg; }
    }
    document.getElementById('stat-region').textContent = maxRegion;
    document.getElementById('stat-region-detail').textContent = `avg ${maxVal.toFixed(1)} per 100k`;

    const monthImpact = groupBy(disasterRows, 'month');
    let peakMonth = '—', peakVal = 0;
    for (const [m, rows] of Object.entries(monthImpact)) {
        const avg = mean(rows.map(config.metric));
        if (avg > peakVal) { peakVal = avg; peakMonth = MONTH_NAMES[+m - 1]; }
    }
    document.getElementById('stat-month').textContent = peakMonth;

    // trend chart + 2026 forecast
    const years = [...new Set(data.map(r => +r.year))].sort();
    const disasterByYear = groupBy(disasterRows, 'year');
    const nonByYear = groupBy(nonDisasterRows, 'year');
    const trendDisaster = years.map(y => mean((disasterByYear[y] || []).map(config.metric)));
    const trendNon = years.map(y => mean((nonByYear[y] || []).map(config.metric)));

    const trendTraces = [
        { x: years, y: trendDisaster, name: config.name + ' weeks', type: 'scatter', mode: 'lines+markers',
          line: { color: '#2d3436', width: 2 }, marker: { size: 4 } },
        { x: years, y: trendNon, name: 'Normal weeks', type: 'scatter', mode: 'lines+markers',
          line: { color: '#ccc', width: 2, dash: 'dot' }, marker: { size: 4 } }
    ];

    Plotly.newPlot('trend-chart', trendTraces, {
        ...PLOTLY_LAYOUT, height: 280,
        legend: { x: 0, y: 1.15, orientation: 'h', font: { size: 10 } },
        yaxis: { ...PLOTLY_LAYOUT.yaxis, title: { text: config.metricLabel, font: { size: 10 } } }
    }, PLOTLY_CONFIG);

    // geo map
    const countryHover = {};
    const countryImpactMap = {};
    countries.forEach(c => {
        const allRows = data.filter(r => r.country_name === c);
        const rows = disasterRows.filter(r => r.country_name === c);
        const totalWeeks = allRows.length;
        const disasterWeeks = rows.length;
        const freq = totalWeeks > 0 ? ((disasterWeeks / totalWeeks) * 100).toFixed(1) : 0;
        const avgAccess = mean(allRows.map(r => +r.healthcare_access_index));
        const accessLabel = avgAccess < 40 ? 'Low' : avgAccess < 70 ? 'Moderate' : 'High';
        const pop = allRows.length > 0 ? (+allRows[0].population_millions).toFixed(1) : '—';
        countryImpactMap[c] = mean(rows.map(config.metric));
        countryHover[c] = `<b>${c}</b><br>` +
            `${config.name} Frequency: ${disasterWeeks}/${totalWeeks} weeks (${freq}%)<br>` +
            `Avg ${config.metricLabel}: ${countryImpactMap[c].toFixed(1)} per 100k<br>` +
            `Healthcare Access: ${accessLabel} (${avgAccess.toFixed(0)})<br>` +
            `Population: ${pop}M`;
    });

    Plotly.newPlot('heatmap-chart', [{
        type: 'choropleth',
        locations: countries.map(c => countryMeta[c]?.code || ''),
        z: countries.map(c => countryImpactMap[c]),
        text: countries.map(c => countryHover[c]),
        hovertemplate: '%{text}<extra></extra>',
        colorscale: [[0,'#fff5f0'],[0.2,'#fee0d2'],[0.4,'#fcbba1'],[0.6,'#fc9272'],[0.8,'#ef6548'],[1,'#c0392b']],
        colorbar: { thickness: 12, len: 0.6, tickfont: { size: 10, color: '#999' }, title: '' },
        marker: { line: { color: '#e0e0e0', width: 0.5 } }
    }], {
        ...PLOTLY_LAYOUT, height: 420,
        margin: { l: 0, r: 0, t: 0, b: 0 },
        geo: {
            showframe: false, showcoastlines: true, coastlinecolor: '#ddd',
            projection: { type: 'natural earth' }, bgcolor: 'transparent',
            landcolor: '#f8f9fa', showland: true, countrycolor: '#e8e8e8', showcountries: true
        }
    }, PLOTLY_CONFIG);

    // seasonal + forecast overlay (uses all data, not just disaster weeks)
    const months = [1,2,3,4,5,6,7,8,9,10,11,12];
    const monthAll = groupBy(data, 'month');
    const seasonalY = months.map(m => mean((monthAll[m] || []).map(config.metric)));
    const forecastMonthly = config.forecastKey ? getMonthlyForecasts(countries, config.forecastKey) : null;

    const seasonalTraces = [{
        x: MONTH_NAMES, y: seasonalY, name: 'Historical', mode: 'lines+markers',
        line: { color: '#2d3436', width: 3 }, marker: { size: 6, color: '#2d3436' }
    }];

    if (forecastMonthly) {
        seasonalTraces.push({
            x: MONTH_NAMES, y: forecastMonthly, name: 'ML Forecast', mode: 'lines+markers',
            line: { color: '#c0392b', width: 3, dash: 'dash' }, marker: { size: 6, color: '#c0392b' }
        });
    }

    Plotly.newPlot('seasonal-chart', seasonalTraces, {
        height: 320,
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff',
        font: { family: '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif', size: 11, color: '#555' },
        margin: { l: 50, r: 20, t: 10, b: 40 },
        xaxis: { gridcolor: '#eee' },
        yaxis: { gridcolor: '#eee', title: { text: config.metricLabel, font: { size: 10 } } },
        legend: { x: 0, y: 1.15, orientation: 'h', font: { size: 10 } }
    }, { displayModeBar: false, responsive: true });

    // vulnerability table
    const countryStats = countries.map(c => {
        const rows = disasterRows.filter(r => r.country_name === c);
        const fc = forecastData[c];
        let predicted = '—';
        if (fc && config.forecastKey) {
            const vals = fc.map(m => m[config.forecastKey] || 0);
            predicted = (vals.reduce((a, b) => a + b, 0) / vals.length).toFixed(1);
        }
        return {
            country: c,
            region: countryMeta[c]?.region || '',
            weeks: rows.length,
            impact: mean(rows.map(config.metric)),
            access: mean(rows.length > 0 ? rows.map(r => +r.healthcare_access_index) : data.filter(r => r.country_name === c).map(r => +r.healthcare_access_index)),
            predicted
        };
    }).sort((a, b) => b.impact - a.impact).slice(0, 10);

    const maxImpact = Math.max(...countryStats.map(c => c.impact)) * 1.5 || 1;
    const maxForecast = Math.max(...countryStats.map(c => parseFloat(c.predicted) || 0)) * 1.5 || 1;
    const maxAccess = Math.max(...countryStats.map(c => c.access)) || 1;

    function inlineBar(value, max, color) {
        const pct = max > 0 ? Math.min(100, (value / max) * 100) : 0;
        return `<div style="display:flex;align-items:center;gap:10px">
            <div style="flex:1;height:10px;background:#f0f0f0;border-radius:5px;min-width:100px">
                <div style="width:${pct}%;height:100%;background:${color};border-radius:5px"></div>
            </div>
            <span style="font-size:0.75rem;color:#888;min-width:32px;text-align:right">${value}</span>
        </div>`;
    }

    document.getElementById('vuln-tbody').innerHTML = countryStats.map((c, i) => `
        <tr>
            <td>${i + 1}</td>
            <td>${c.country}</td>
            <td>${c.region}</td>
            <td>${c.weeks}</td>
            <td style="min-width:180px">${inlineBar(c.impact.toFixed(1), maxImpact, '#2d3436')}</td>
            <td style="min-width:180px">${inlineBar(c.predicted, maxForecast, '#c0392b')}</td>
            <td>${inlineBar(c.access.toFixed(1), maxAccess, '#6c9')}</td>
        </tr>
    `).join('');
}

function getMonthlyForecasts(countries, key) {
    const relevant = countries.filter(c => forecastData[c]);
    if (relevant.length === 0) return null;
    return [1,2,3,4,5,6,7,8,9,10,11,12].map(m => {
        const vals = relevant.map(c => forecastData[c][m - 1]?.[key] || 0);
        return vals.reduce((a, b) => a + b, 0) / vals.length;
    });
}

function mean(arr) {
    const nums = arr.filter(v => !isNaN(v) && v !== null);
    return nums.length > 0 ? nums.reduce((a, b) => a + b, 0) / nums.length : 0;
}

function groupBy(arr, key) {
    const groups = {};
    arr.forEach(r => { (groups[r[key]] = groups[r[key]] || []).push(r); });
    return groups;
}
</script>

</body>
</html>
